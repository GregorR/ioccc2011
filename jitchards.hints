This is a JIT entirely written in barely-portablish C. In fact, if it just so
happens to work on any given platform, that's a coincidence. And yet, it works
on many platforms, because they're just similar enough!

Platform-specific code is discouraged in IOCCC. That's why JITchards includes
no assembler and determines all platform-specific information dynamically at
runtime. I have carefully arranged the functions to have a maximum chance of
working by coincidence. And I assure you, when they work, it's by coincidence.

On some platforms, optimizations are /required/ for JITchards to be able to
detect function prologues and epilogues properly. On others, optimizations
won't work. Play with it, you just might get a working JIT.


Warnings you may get:

 * None of my functions return anything, even though they're all declared as
   int. Oh well, they don't need to.


Behaviors and optimizations that may break JITchards:

 * Anything that calls a function from every generated function, e.g. overflow
   detection.
   * This accounts for -fno-stack-check in owcc
 * Incomplete support for register parameters.
 * Happening to overwrite the register parameter by coincidence :(
 * Rearranging or padding functions (functions must appear in output in the
   exact order they appear in the .c file, which is the common default but is
   changed by optimization flags)
   * This accounts for -fno-align-functions -fno-toplevel-reorder
   * Actually even -O1 rearranges, but in a way that turns out to be harmless
 * Tail call optimization
   * This accounts for -fno-optimize-sibling-calls
 * Branch delay instructions on returns
   * This accounts for -fno-delayed-branch
 * Assigning literal integers by storing them in .text and copying them (gcc
   ARM does this)
 * Inter-procedural code folding.
 * Braindead optimization-free function prologues (e.g. subtract 0 from SP)


Known-working platforms (for practical reasons I've only tested with gcc,
marked * if changed since last test):

gcc 4.6.2 + x86_64:
    -O0
    -O1
    -O2 -fno-align-functions -fno-toplevel-reorder -fno-optimize-sibling-calls
    -O3 -fno-align-functions -fno-toplevel-reorder -fno-optimize-sibling-calls

gcc 4.6.2 + x86:
    -O0
    -O1
    -O2 -fno-align-functions -fno-toplevel-reorder -fno-optimize-sibling-calls
    -O3 -fno-align-functions -fno-toplevel-reorder -fno-optimize-sibling-calls

owcc 1.9 + x86:
    -b win32 -DNOMMAP -fno-stack-check -O0
    (-O1 does inter-procedural code folding which doesn't seem to be removed by
        -fno-optimize-sibling-calls)

tcc 0.9.25 + x86:
    (no flags)
    -O1
    -O2

gcc 4.4.5 + sparc:
    -O0
    (-O1 and higher won't work due to a combined pop/return instruction that
        makes the epilogue inconsistent)

gcc 4.4.5 + mips/mipsel:
    -O0
    -O1 -fno-delayed-branch
    (-O2 -fno-delayed-branch -fno-toplevel-reorder -fno-optimize-sibling-calls doesn't quite work)

gcc 4.4.5 + arm:
    -O0
    -O1 -fno-toplevel-reorder
    -O2 -fno-toplevel-reorder
    -O3 -fno-toplevel-reorder
